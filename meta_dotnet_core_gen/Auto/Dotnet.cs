// ******************************************************************************************************************************
// Filename:    Dotnet.cs
// Description: In memory representation of various DotNet and AspNet runtime versions and their corresponding hashes and links.
//              Part of these classes was generated using XmlToDataClass program (Dotnet.AutoGen.cs). This file supplements the
//              autogenerated code to add additional functionality.
// ******************************************************************************************************************************
// Copyright © Richard Dunkley 2023
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// ******************************************************************************************************************************
using System.Net;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;
using static meta_dotnet_core_gen.Auto.Dotnet.Runtime;

namespace meta_dotnet_core_gen.Auto
{
	//***************************************************************************************************************************
	/// <summary>In memory representation of .Net download runtime information.</summary>
	//***************************************************************************************************************************
	public partial class Dotnet
	{
		#region Classes

		//***********************************************************************************************************************
		/// <summary>Represents the various runtimes that can be downloaded.</summary>
		//***********************************************************************************************************************
		public partial class Runtime
		{
			#region Classes

			//*******************************************************************************************************************
			/// <summary>In memory representation of a specific build of the runtime.</summary>
			//*******************************************************************************************************************
			public partial class Build
			{
				#region Classes

				//***************************************************************************************************************
				/// <summary>Architecture supported by the version.</summary>
				//***************************************************************************************************************
				public partial class Arch
				{
					#region Properties

					/// <summary>
					///   Gets or sets whether the architecture is new (not what was loaded from disk).
					/// </summary>
					public bool New { get; set; }

					/// <summary>
					///   Gets or sets a new online link that is different from what was stored on disk (<see cref="Link"/>).
					/// </summary>
					public string NewLink { get; set; }

					/// <summary>
					///   Gets or sets a new SHA-512 hash that is different from what was stored on disk (<see cref="Sha512"/>).
					/// </summary>
					public string NewSha512 { get; set; }

					#endregion

					#region Methods

					/// <summary>
					///   Downloads the architecture file package from the web, validates the SHA-512 hash, and computes the MD5 and SHA-256 hashes.
					/// </summary>
					/// <param name="tmpPath">Temporary path to store the downloaded file.</param>
					/// <exception cref="InvalidDataException">The downloaded file's SHA-512 hash doesn't match the online provided one.</exception>
					public void UpdateNeededHashes(string tmpPath)
					{
						var uri = new Uri(this.Link);
						var fileName = uri.Segments.Last().TrimEnd('/');
						var downloadedFile = Path.Combine(tmpPath, fileName);

						if (!Directory.Exists(tmpPath))
							Directory.CreateDirectory(tmpPath);

						if (File.Exists(downloadedFile))
							File.Delete(downloadedFile);

						// Download the file.
						Console.Write($"Downloading {fileName}...");
						using (var client = new WebClient())
						{
							Thread.Sleep(1000);
							client.DownloadFile(this.Link, downloadedFile);
						}

						byte[] data = File.ReadAllBytes(downloadedFile);
						Console.Write("Verifying...");
						string computedSha;
						using (SHA512 sha = SHA512.Create())
						{
							computedSha = ComputeHash(sha, data);
						}

						if (string.Compare(computedSha, this.Sha512, true) != 0)
						{
							Console.WriteLine("failed!");
							throw new InvalidDataException($"The computed SHA-512 ({computedSha}) for {fileName} does not match the online provided one ({this.Sha512})");
						}

						if (Md5 == null)
						{
							Console.Write($"Computing MD5...");
							using (MD5 md5 = MD5.Create())
							{
								Md5 = ComputeHash(md5, data);
							}
						}

						if(Sha256 == null)
						{
							Console.Write($"Computing SHA-256...");
							using (SHA256 sha = SHA256.Create())
							{
								Sha256 = ComputeHash(sha, data);
							}
						}
						Console.WriteLine("done!");
					}

					private static string ComputeHash(HashAlgorithm hashAlgorithm, byte[] data)
					{
						// Compute the hash.
						byte[] hash = hashAlgorithm.ComputeHash(data);

						var sb = new StringBuilder();
						for (int i = 0; i < hash.Length; i++)
							sb.Append(hash[i].ToString("x2"));
						return sb.ToString();
					}

					/// <summary>
					///   Loads the information from the meta file specified.
					/// </summary>
					/// <param name="target">Target architecture of the file to be parsed.</param>
					/// <param name="filePath">Path to the file to parse (should be a .inc file).</param>
					/// <returns><see cref="Arch"/> object containing the parsed information.</returns>
					public static Arch LoadRecipe(TargetEnum target, string filePath)
					{
						string link = null;
						string md5 = null;
						string sha256 = null;

						string[] lines = File.ReadAllLines(filePath);
						foreach (string line in lines)
						{
							if (line.StartsWith("SRC_URI[md5sum]"))
								md5 = line.Split('"', StringSplitOptions.RemoveEmptyEntries)[1];
							else if (line.StartsWith("SRC_URI[sha256sum]"))
								sha256 = line.Split('"', StringSplitOptions.RemoveEmptyEntries)[1];
							else if (line.StartsWith("SRC_URI"))
								link = line.Split('"', StringSplitOptions.RemoveEmptyEntries)[1].Split(';')[0];
						}

						return new Arch(link, md5, sha256, null, target);
					}

					/// <summary>
					///   Updates an existing meta file with new updated information.
					/// </summary>
					/// <param name="runtimeFolder">Runtime folder containing the bitbake recipes.</param>
					/// <param name="runtime"><see cref="Runtime"/> to be updated.</param>
					/// <param name="build"><see cref="Build"/> to be updated.</param>
					/// <exception cref="ArgumentNullException"><paramref name="runtimeFolder"/>, <paramref name="runtime"/> or <paramref name="build"/> is null.</exception>
					public void UpdateMetaFile(string runtimeFolder, Runtime runtime, Build build)
					{
						if (runtimeFolder == null)
							throw new ArgumentNullException(nameof(runtimeFolder));
						if (runtime == null)
							throw new ArgumentNullException(nameof(runtime));
						if (build == null)
							throw new ArgumentNullException(nameof(build));

						string ver = $"{runtime.Version.ToString(2)}.{build.Version}";
						string fileName = $"{Enum.GetName(runtime.Name).ToLower()}-core_{ver}_{Enum.GetName(this.Target).ToLower()}.inc";
						string filePath = Path.Combine(runtimeFolder, fileName);

						string[] lines = File.ReadAllLines(filePath);
						for(int i = 0; i < lines.Length; i++)
						{
							if (lines[i].StartsWith("SRC_URI[md5sum]"))
								lines[i] = $"SRC_URI[md5sum] = \"{this.Md5.ToLower()}\"";
							else if (lines[i].StartsWith("SRC_URI[sha256sum]"))
								lines[i] = $"SRC_URI[sha256sum] = \"{this.Sha256.ToLower()}\"";
							else if (lines[i].StartsWith("SRC_URI"))
								lines[i] = $"SRC_URI = \"{this.Link};subdir=dotnet-${{PV}}\"";
						}

						File.WriteAllLines(filePath, lines);
					}

					/// <summary>
					///   Generates a meta file from the architecure. An existing file will be overwritten.
					/// </summary>
					/// <param name="runtimeFolder">Runtime folder containing the bitbake recipes.</param>
					/// <param name="runtime"><see cref="Runtime"/> to be generated.</param>
					/// <param name="build"><see cref="Build"/> to be generated.</param>
					/// <param name="copyrightHolder">Copyright holder to place in the files.</param>
					/// <exception cref="ArgumentNullException"><paramref name="runtimeFolder"/>, <paramref name="runtime"/>, <paramref name="build"/>, or <paramref name="copyrightHolder"/> is null.</exception>
					public void GenerateMetaFile(string runtimeFolder, Runtime runtime, Build build, string copyrightHolder)
					{
						if (runtimeFolder == null)
							throw new ArgumentNullException(nameof(runtimeFolder));
						if (runtime == null)
							throw new ArgumentNullException(nameof(runtime));
						if (build == null)
							throw new ArgumentNullException(nameof(build));
						if(copyrightHolder == null)
							throw new ArgumentNullException(nameof(copyrightHolder));

						string runtimeAdd = string.Empty;
						if (runtime.Name == NameEnum.AspNet)
							runtimeAdd = "ASP ";

						string ver = $"{runtime.Version.ToString(2)}.{build.Version}";
						string fileName = $"{Enum.GetName(runtime.Name).ToLower()}-core_{ver}_{Enum.GetName(this.Target).ToLower()}.inc";
						using (StreamWriter sw = new StreamWriter(Path.Combine(runtimeFolder, fileName), false))
						{
							sw.WriteLine($"###################################################################################################");
							sw.WriteLine($"# Contains the URL and checksums to download version {ver} of the {Enum.GetName(this.Target).ToUpper()} {runtimeAdd}.Net");
							sw.WriteLine($"# runtime from Microsoft.");
							sw.WriteLine($"# Copyright {copyrightHolder} {DateTime.Now.Year}");
							sw.WriteLine($"# Auto-generated using {Assembly.GetExecutingAssembly().GetName().Name}");
							sw.WriteLine($"###################################################################################################");
							sw.WriteLine($"SRC_URI = \"{this.Link};subdir={Enum.GetName(runtime.Name).ToLower()}-${{PV}}\"");
							sw.WriteLine();
							sw.WriteLine($"# SHA-512 hash is '{this.Sha512.ToLower()}'");
							sw.WriteLine();
							sw.WriteLine($"SRC_URI[md5sum] = \"{this.Md5.ToLower()}\"");
							sw.WriteLine($"SRC_URI[sha256sum] = \"{this.Sha256.ToLower()}\"");
							sw.WriteLine();
						}
					}

					/// <summary>
					///   Gets the <see cref="TargetEnum"/> from the link text Microsoft uses on their webpage.
					/// </summary>
					/// <param name="linkText">Link text.</param>
					/// <returns>Nullable <paramref name="linkText"/>. If null then the link text wasn't recognized.</returns>
					public static TargetEnum? GetLinkTarget(string linkText)
					{
						switch (linkText)
						{
							case "Arm32":
								return TargetEnum.Arm;
							case "Arm64":
								return TargetEnum.Arm64;
							case "x64":
								return TargetEnum.X64;
							default:
								return null;
						}
					}

					#endregion
				}

				#endregion

				#region Methods

				/// <summary>
				///   Finds the <see cref="Arch"/> associated with the <see cref="Arch.TargetEnum"/>.
				/// </summary>
				/// <param name="type"><see cref="Arch.TargetEnum"/> to search the <see cref="ChildArchs"/> for.</param>
				/// <returns><see cref="Arch"/> found in <see cref="ChildArchs"/> or null if none was found.</returns>
				public Arch FindArch(Arch.TargetEnum type)
				{
					foreach(var arch in this.ChildArchs)
					{
						if (arch.Target == type) return arch;
					}
					return null;
				}

				/// <summary>
				///   Generated meta files for all the architectures in this build.
				/// </summary>
				/// <param name="runtimeFolder">Runtime folder containing the bitbake recipes.</param>
				/// <param name="runtime"><see cref="Runtime"/> to be generated.</param>
				/// <param name="copyrightHolder">Copyright holder to place in the files.</param>
				/// <exception cref="ArgumentNullException"><paramref name="runtimeFolder"/>, <paramref name="runtime"/>, or <paramref name="copyrightHolder"/> is null.</exception>
				public void GenerateMetaFiles(string runtimeFolder, Runtime runtime, string copyrightHolder)
				{
					if (runtimeFolder == null)
						throw new ArgumentNullException(nameof(runtimeFolder));
					if (runtime == null)
						throw new ArgumentNullException(nameof(runtime));
					if (copyrightHolder == null)
						throw new ArgumentNullException(nameof(copyrightHolder));

					string runtimeAdd = string.Empty;
					if (runtime.Name == NameEnum.AspNet)
						runtimeAdd = "ASP ";

					// Write inc file.
					string runtimeLower = Enum.GetName(runtime.Name).ToLower();
					string ver = $"{runtime.Version.ToString(2)}.{this.Version}";
					string fileName = $"{runtimeLower}-core_{ver}.inc";
					using (StreamWriter sw = new StreamWriter(Path.Combine(runtimeFolder, fileName), false))
					{
						sw.WriteLine($"###################################################################################################");
						sw.WriteLine($"# Contains additional parameters for the recipe to download the release binaries from Microsoft.");
						sw.WriteLine($"# Copyright {copyrightHolder} {DateTime.Now.Year}");
						sw.WriteLine($"# Auto-generated using {Assembly.GetExecutingAssembly().GetName().Name}");
						sw.WriteLine($"###################################################################################################");
						sw.WriteLine($"SUMMARY = \"Contains the binaries for Microsoft's {runtimeAdd}.NET {ver}\"");
						sw.WriteLine($"HOMEPAGE = \"https://dotnet.microsoft.com/download/dotnet/{runtime.Version.ToString(2)}\"");
						sw.WriteLine();
						sw.WriteLine("DOTNET_RUNTIME_ARCH = \"none\"");
						sw.WriteLine($"DOTNET_RUNTIME_ARCH:arm = \"arm\"");
						sw.WriteLine($"DOTNET_RUNTIME_ARCH:x86-64 = \"x64\"");
						sw.WriteLine($"DOTNET_RUNTIME_ARCH:x86_64 = \"x64\"");
						sw.WriteLine($"DOTNET_RUNTIME_ARCH:aarch64 = \"arm64\"");
						sw.WriteLine();
						sw.WriteLine("# This is here because it doesn't seem like bitbake likes ${PV} used in require statements.");
						sw.WriteLine($"require recipes-runtime/{runtimeLower}-core/{runtimeLower}-core_{ver}_${{DOTNET_RUNTIME_ARCH}}.inc");
						sw.WriteLine();
					}

					// Write BB file.
					fileName = $"{runtimeLower}-core_{ver}.bb";
					using (StreamWriter sw = new StreamWriter(Path.Combine(runtimeFolder, fileName), false))
					{
						sw.WriteLine($"###################################################################################################");
						sw.WriteLine($"# Contains the recipe to download the release binaries from Microsoft for the version");
						sw.WriteLine($"# {ver} {runtimeAdd}.Net runtime.");
						sw.WriteLine($"# Copyright {copyrightHolder} {DateTime.Now.Year}");
						sw.WriteLine($"# Auto-generated using {Assembly.GetExecutingAssembly().GetName().Name}");
						sw.WriteLine($"###################################################################################################");
						sw.WriteLine();
						sw.WriteLine($"require recipes-runtime/{runtimeLower}-core/{runtimeLower}-core_{ver}.inc");
						sw.WriteLine($"require recipes-runtime/{runtimeLower}-core/{runtimeLower}-core_{runtime.Version.Major}.x.x.inc");
						sw.WriteLine();
					}

					// Write the none architecture file.
					fileName = $"{runtimeLower}-core_{ver}_none.inc";
					using (StreamWriter sw = new StreamWriter(Path.Combine(runtimeFolder, fileName), false))
					{
						sw.WriteLine($"###################################################################################################");
						sw.WriteLine($"# Dummy file in case the architecture isn't supported (prevents Bitbaker parser from crashing).");
						sw.WriteLine($"# Copyright {copyrightHolder} {DateTime.Now.Year}");
						sw.WriteLine($"# Auto-generated using {Assembly.GetExecutingAssembly().GetName().Name}");
						sw.WriteLine($"###################################################################################################");
						sw.WriteLine();
					}

					// Write the architecture files.
					foreach (var arch in this.ChildArchs)
						arch.GenerateMetaFile(runtimeFolder, runtime, this, copyrightHolder);
				}

				#endregion
			}

			#endregion

			#region Methods

			/// <summary>
			///   Finds a <see cref="Build"/> object in <see cref="ChildBuilds"/>.
			/// </summary>
			/// <param name="version">Version of the <see cref="Build"/> to locate.</param>
			/// <returns><see cref="Build"/> found in <see cref="ChildBuilds"/> or null if none was found.</returns>
			public Build FindBuild(int version)
			{
				foreach (var build in this.ChildBuilds)
				{
					if (build.Version == version)
						return build;
				}
				return null;
			}

			#endregion
		}

		#endregion

		#region Methods

		/// <summary>
		///   Finds a <see cref="Runtime"/> object in <see cref="ChildRuntimes"/>.
		/// </summary>
		/// <param name="name"><see cref="NameEnum"/> of the <see cref="Runtime"/> to locate.</param>
		/// <param name="majorVersion">Major version of the runtime.</param>
		/// <returns><see cref="Runtime"/> found in <see cref="ChildRuntimes"/> or null if none was found.</returns>
		public Runtime FindRuntime(NameEnum name, int majorVersion)
		{
			foreach(var runtime in this.ChildRuntimes)
			{
				if (runtime.Name == name && runtime.Version.Major == majorVersion)
					return runtime;
			}
			return null;
		}

		/// <summary>
		///   Gets a list of all the new packages in the <see cref="Dotnet"/> object.
		/// </summary>
		/// <returns>List of each target architecture.</returns>
		public string[] GetNewVersionList()
		{
			var list = new List<string>();
			foreach(var runtime in this.ChildRuntimes)
			{
				foreach(var build in runtime.ChildBuilds)
				{
					foreach(var arch in build.ChildArchs)
					{
						if(arch.New)
							list.Add($"{runtime.Name} {runtime.Version.ToString(2)}.{build.Version} ({arch.Target})");
					}
				}
			}
			return list.ToArray();
		}

		/// <summary>
		///   Gets a list of all the packages whose link has changed.
		/// </summary>
		/// <returns>List of each target architecture.</returns>
		public string[] GetChangedLinks()
		{
			var list = new List<string>();
			foreach (var runtime in this.ChildRuntimes)
			{
				foreach (var build in runtime.ChildBuilds)
				{
					foreach (var arch in build.ChildArchs)
					{
						if (arch.NewLink != null)
							list.Add($"{runtime.Name} {runtime.Version.ToString(2)}.{build.Version} ({arch.Target})");
					}
				}
			}
			return list.ToArray();
		}

		/// <summary>
		///   Gets a list of all the packages whose SHA-512 Hash has changed.
		/// </summary>
		/// <returns>List of each target architecture.</returns>
		public string[] GetChangedChecksum()
		{
			var list = new List<string>();
			foreach (var runtime in this.ChildRuntimes)
			{
				foreach (var build in runtime.ChildBuilds)
				{
					foreach (var arch in build.ChildArchs)
					{
						if (arch.NewSha512 != null)
							list.Add($"{runtime.Name} {runtime.Version.ToString(2)}.{build.Version} ({arch.Target})");
					}
				}
			}
			return list.ToArray();
		}

		/// <summary>
		///   Gets a list of all the packages needing hash information.
		/// </summary>
		/// <returns>List of each target architecture.</returns>
		public string[] GetFilesNeedingHashes()
		{
			var list = new List<string>();
			foreach (var runtime in this.ChildRuntimes)
			{
				foreach (var build in runtime.ChildBuilds)
				{
					foreach (var arch in build.ChildArchs)
					{
						if (arch.Sha512 == null || arch.Sha256 == null || arch.Md5 == null)
							list.Add($"{runtime.Name} {runtime.Version.ToString(2)}.{build.Version} ({arch.Target})");
					}
				}
			}
			return list.ToArray();
		}

		/// <summary>
		///   Updates the hash for any that need it. Note: this can take a very long time to run.
		/// </summary>
		/// <param name="tmpPath">Temporary path to store the downloaded files. Any files in this path with the same name may be overwritten.</param>
		public void UpdateHashes(string tmpPath)
		{
			foreach (var runtime in this.ChildRuntimes)
			{
				foreach (var build in runtime.ChildBuilds)
				{
					foreach (var arch in build.ChildArchs)
					{
						if (arch.Sha512 == null || arch.Sha256 == null || arch.Md5 == null)
						{
							try
							{
								arch.UpdateNeededHashes(tmpPath);
							}
							catch(InvalidDataException e)
							{
								Console.WriteLine(e.Message);
							}
						}
					}
				}
			}
		}

		/// <summary>
		///   Finds all the packages where the meta version isn't online.
		/// </summary>
		/// <param name="online"><see cref="Dotnet"/> object containing online information.</param>
		/// <param name="meta"><see cref="Dotnet"/> object containing information parsed from the meta files.</param>
		/// <returns>List of each item (runtime, build or target architecture).</returns>
		public static string[] FindMetaThatIsntOnline(Dotnet online, Dotnet meta)
		{
			var list = new List<string>();

			// Find any meta versions that don't exist online.
			foreach (var metaRuntime in meta.ChildRuntimes)
			{
				var onlineRuntime = online.FindRuntime(metaRuntime.Name, metaRuntime.Version.Major);
				if (onlineRuntime == null)
				{
					list.Add($"{metaRuntime.Name} {metaRuntime.Version.ToString(2)}");
				}
				else
				{
					foreach (var metaBuild in metaRuntime.ChildBuilds)
					{
						var onlineBuild = onlineRuntime.FindBuild(metaBuild.Version);
						if(onlineBuild == null)
						{
							list.Add($"{metaRuntime.Name} {metaRuntime.Version.ToString(2)}.{metaBuild.Version}");
						}
						else
						{
							foreach (var metaArch in metaBuild.ChildArchs)
							{
								var onlineArch = onlineBuild.FindArch(metaArch.Target);
								if(onlineArch == null)
									list.Add($"{metaRuntime.Name} {metaRuntime.Version.ToString(2)}.{metaBuild.Version} ({metaArch.Target})");
							}
						}
					}
				}
			}
			return list.ToArray();
		}

		/// <summary>
		///   Finds all the packages where the meta version exists, but doesn't match the online information.
		/// </summary>
		/// <param name="online"><see cref="Dotnet"/> object containing online information.</param>
		/// <param name="meta"><see cref="Dotnet"/> object containing information parsed from the meta files.</param>
		/// <returns>List of each target architecture.</returns>
		public static string[] FindDifferencesInMeta(Dotnet online, Dotnet meta)
		{
			var list = new List<string>();

			// Find any meta versions that don't match online.
			foreach (var metaRuntime in meta.ChildRuntimes)
			{
				var onlineRuntime = online.FindRuntime(metaRuntime.Name, metaRuntime.Version.Major);
				if (onlineRuntime != null)
				{
					foreach (var metaBuild in metaRuntime.ChildBuilds)
					{
						var onlineBuild = onlineRuntime.FindBuild(metaBuild.Version);
						if (onlineBuild != null)
						{
							foreach (var metaArch in metaBuild.ChildArchs)
							{
								var onlineArch = onlineBuild.FindArch(metaArch.Target);
								if (onlineArch != null)
								{
									if(string.Compare(onlineArch.Link, metaArch.Link, true) != 0 || (metaArch.Sha512 != null && string.Compare(onlineArch.Sha512, metaArch.Sha512, true) != 0))
										list.Add($"{metaRuntime.Name} {metaRuntime.Version.ToString(2)}.{metaBuild.Version} ({metaArch.Target})");
								}
							}
						}
					}
				}
			}
			return list.ToArray();
		}

		/// <summary>
		///   Finds all the packages where the online version doesn't exist in the meta files.
		/// </summary>
		/// <param name="online"><see cref="Dotnet"/> object containing online information.</param>
		/// <param name="meta"><see cref="Dotnet"/> object containing information parsed from the meta files.</param>
		/// <returns>List of each target architecture.</returns>
		public static string[] FindOnlineThatIsntMeta(Dotnet online, Dotnet meta)
		{
			var list = new List<string>();

			// Find any meta versions that don't exist online.
			foreach (var onlineRuntime in online.ChildRuntimes)
			{
				var metaRuntime = meta.FindRuntime(onlineRuntime.Name, onlineRuntime.Version.Major);
				if (metaRuntime == null)
				{
					list.Add($"{onlineRuntime.Name} {onlineRuntime.Version.ToString(2)}");
				}
				else
				{
					foreach (var onlineBuild in onlineRuntime.ChildBuilds)
					{
						var metaBuild = metaRuntime.FindBuild(onlineBuild.Version);
						if (metaBuild == null)
						{
							list.Add($"{onlineRuntime.Name} {onlineRuntime.Version.ToString(2)}.{onlineBuild.Version}");
						}
						else
						{
							foreach (var onlineArch in onlineBuild.ChildArchs)
							{
								var metaArch = metaBuild.FindArch(onlineArch.Target);
								if (metaArch == null)
									list.Add($"{onlineRuntime.Name} {onlineRuntime.Version.ToString(2)}.{onlineBuild.Version} ({onlineArch.Target})");
							}
						}
					}
				}
			}
			return list.ToArray();
		}

		/// <summary>
		///   Update the meta files to match the online values. This will update existing values as well as generate new files.
		/// </summary>
		/// <param name="online"><see cref="Dotnet"/> object containing online information.</param>
		/// <param name="meta"><see cref="Dotnet"/> object containing information parsed from the meta files.</param>
		/// <param name="metaFolder">Meta layer folder.</param>
		/// <param name="copyrightHolder">String containing who newly generated file copyright should belong to.</param>
		public static void UpdateMeta(Dotnet online, Dotnet meta, string metaFolder, string copyrightHolder)
		{
			var list = new List<string>();

			// Find any meta versions that don't exist.
			foreach (var onlineRuntime in online.ChildRuntimes)
			{
				var runtimeFolder = Path.Combine(metaFolder, "recipes-runtime", $"{Enum.GetName(onlineRuntime.Name).ToLower()}-core");
				var metaRuntime = meta.FindRuntime(onlineRuntime.Name, onlineRuntime.Version.Major);
				if (metaRuntime == null)
				{
					foreach(var onlineBuild in onlineRuntime.ChildBuilds)
						onlineBuild.GenerateMetaFiles(runtimeFolder, onlineRuntime, copyrightHolder);
				}
				else
				{
					foreach (var onlineBuild in onlineRuntime.ChildBuilds)
					{
						var metaBuild = metaRuntime.FindBuild(onlineBuild.Version);
						if (metaBuild == null)
						{
							onlineBuild.GenerateMetaFiles(runtimeFolder, onlineRuntime, copyrightHolder);
						}
						else
						{
							foreach (var onlineArch in onlineBuild.ChildArchs)
							{
								var metaArch = metaBuild.FindArch(onlineArch.Target);
								if (metaArch == null)
								{
									onlineArch.GenerateMetaFile(runtimeFolder, onlineRuntime, onlineBuild, copyrightHolder);
								}
								else
								{
									if (string.Compare(onlineArch.Link, metaArch.Link, true) != 0 || (metaArch.Sha512 != null && string.Compare(onlineArch.Sha512, metaArch.Sha512, true) != 0))
										onlineArch.UpdateMetaFile(runtimeFolder, onlineRuntime, onlineBuild);
								}
							}
						}
					}
				}
			}
		}

		#endregion
	}
}
